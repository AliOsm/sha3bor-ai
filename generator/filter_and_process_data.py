import argparse

from typing import List

import pandas as pd


def filter_data(data: pd.DataFrame, required_metres: int) -> pd.DataFrame:
    """
    تقوم هذه الدالة بتصفية البيانات من خلال:
    - إزالة الأبيات التي تنتمي لأحد البحور قليلة التكرار حسب قيمة required_metres.
    - إزالة البيت إذا كانت أحد خصائصه غير موجودة.

    ثم تطبع معلومات البيانات المحدثة وترجعها.
    """

    top_metres = list(data['البحر'].value_counts()[:required_metres].to_dict().keys())

    filtered_data = data[data['البحر'].isin(top_metres)]
    filtered_data = filtered_data.dropna()

    print(f'الحجم قبل التصفية: {data.shape[0]}')
    print(f'الحجم بعد التصفية: {filtered_data.shape[0]}')
    print(f'أكثر {required_metres} بحور استخدامًا: {top_metres}')

    """
    الحجم قبل التصفية: 1831770
    الحجم بعد التصفية: 1581441
    أكثر 9 بحور استخدامًا: ['الطويل', 'الكامل', 'البسيط', 'الخفيف', 'الوافر', 'الرجز', 'الرمل', 'المتقارب', 'السريع']
    """

    return filtered_data


def process_data(data: pd.DataFrame) -> pd.DataFrame:
    """
    تقوم هذه الدالة بمعالجة البيانات من خلال:
    - تحويل القافية "هـ" إلى "هه" لضمان اختلافها عن القافية "ه" بعد المعالجة باستخدام معالج نصوص AraBERT.
    - جمع شطريْ البيت بفاصلة وهي "[شطر]" وإضافة البحر والقافية إلى نهايته.

    ثم تطبع معلومات البيانات المحدثة وترجعها.
    """

    data['القافية'] = data['القافية'].str.replace('ـ', 'ه')
    data['البيت مع تفاصيله'] = (
        data['الشطر الايمن'] + ' [شطر] ' + data['الشطر الايسر'] + ' [' + data['البحر'] + data['القافية'] + ']'
    )

    print(f"البحور: {list(sorted(set(data['البحر'].values)))}")
    print(f"القوافي: {list(sorted(set(data['القافية'].values)))}")
    print(f"البحور مع القوافي: {list(sorted(set(('[' + data['البحر'] + data['القافية'] + ']').values)))}")

    """
    البحور: ['البسيط', 'الخفيف', 'الرجز', 'الرمل', 'السريع', 'الطويل', 'الكامل', 'المتقارب', 'الوافر']
    القوافي: ['ء', 'ؤ', 'ا', 'ب', 'ت', 'ث', 'ج', 'ح', 'خ', 'د', 'ذ', 'ر', 'ز', 'س', 'ش', 'ص', 'ض', 'ط', 'طن', 'ظ', 'ع', 'غ', 'ف', 'ق', 'ك', 'ل', 'لا', 'م', 'ن', 'ه', 'هه', 'و', 'ى', 'ي']
    البحور مع القوافي: ['[البسيطء]', '[البسيطا]', '[البسيطب]', '[البسيطت]', '[البسيطث]', '[البسيطج]', '[البسيطح]', '[البسيطخ]', '[البسيطد]', '[البسيطذ]', '[البسيطر]', '[البسيطز]', '[البسيطس]', '[البسيطش]', '[البسيطص]', '[البسيطض]', '[البسيطط]', '[البسيطظ]', '[البسيطع]', '[البسيطغ]', '[البسيطف]', '[البسيطق]', '[البسيطك]', '[البسيطل]', '[البسيطم]', '[البسيطن]', '[البسيطه]', '[البسيطهه]', '[البسيطو]', '[البسيطى]', '[البسيطي]', '[الخفيفء]', '[الخفيفؤ]', '[الخفيفا]', '[الخفيفب]', '[الخفيفت]', '[الخفيفث]', '[الخفيفج]', '[الخفيفح]', '[الخفيفخ]', '[الخفيفد]', '[الخفيفذ]', '[الخفيفر]', '[الخفيفز]', '[الخفيفس]', '[الخفيفش]', '[الخفيفص]', '[الخفيفض]', '[الخفيفط]', '[الخفيفظ]', '[الخفيفع]', '[الخفيفغ]', '[الخفيفف]', '[الخفيفق]', '[الخفيفك]', '[الخفيفل]', '[الخفيفم]', '[الخفيفن]', '[الخفيفه]', '[الخفيفو]', '[الخفيفى]', '[الخفيفي]', '[الرجزء]', '[الرجزا]', '[الرجزب]', '[الرجزت]', '[الرجزث]', '[الرجزج]', '[الرجزح]', '[الرجزخ]', '[الرجزد]', '[الرجزذ]', '[الرجزر]', '[الرجزز]', '[الرجزس]', '[الرجزش]', '[الرجزص]', '[الرجزض]', '[الرجزط]', '[الرجزظ]', '[الرجزع]', '[الرجزغ]', '[الرجزف]', '[الرجزق]', '[الرجزك]', '[الرجزل]', '[الرجزم]', '[الرجزن]', '[الرجزه]', '[الرجزو]', '[الرجزى]', '[الرجزي]', '[الرملء]', '[الرملا]', '[الرملب]', '[الرملت]', '[الرملث]', '[الرملج]', '[الرملح]', '[الرملخ]', '[الرملد]', '[الرملذ]', '[الرملر]', '[الرملز]', '[الرملس]', '[الرملش]', '[الرملص]', '[الرملض]', '[الرملط]', '[الرملطن]', '[الرملظ]', '[الرملع]', '[الرملغ]', '[الرملف]', '[الرملق]', '[الرملك]', '[الرملل]', '[الرملم]', '[الرملن]', '[الرمله]', '[الرملو]', '[الرملى]', '[الرملي]', '[السريعء]', '[السريعا]', '[السريعب]', '[السريعت]', '[السريعث]', '[السريعج]', '[السريعح]', '[السريعخ]', '[السريعد]', '[السريعذ]', '[السريعر]', '[السريعز]', '[السريعس]', '[السريعش]', '[السريعص]', '[السريعض]', '[السريعط]', '[السريعظ]', '[السريعع]', '[السريعغ]', '[السريعف]', '[السريعق]', '[السريعك]', '[السريعل]', '[السريعم]', '[السريعن]', '[السريعه]', '[السريعو]', '[السريعى]', '[السريعي]', '[الطويلء]', '[الطويلا]', '[الطويلب]', '[الطويلت]', '[الطويلث]', '[الطويلج]', '[الطويلح]', '[الطويلخ]', '[الطويلد]', '[الطويلذ]', '[الطويلر]', '[الطويلز]', '[الطويلس]', '[الطويلش]', '[الطويلص]', '[الطويلض]', '[الطويلط]', '[الطويلظ]', '[الطويلع]', '[الطويلغ]', '[الطويلف]', '[الطويلق]', '[الطويلك]', '[الطويلل]', '[الطويلم]', '[الطويلن]', '[الطويله]', '[الطويلو]', '[الطويلى]', '[الطويلي]', '[الكاملء]', '[الكاملا]', '[الكاملب]', '[الكاملت]', '[الكاملث]', '[الكاملج]', '[الكاملح]', '[الكاملخ]', '[الكاملد]', '[الكاملذ]', '[الكاملر]', '[الكاملز]', '[الكاملس]', '[الكاملش]', '[الكاملص]', '[الكاملض]', '[الكاملط]', '[الكاملظ]', '[الكاملع]', '[الكاملغ]', '[الكاملف]', '[الكاملق]', '[الكاملك]', '[الكاملل]', '[الكاملم]', '[الكاملن]', '[الكامله]', '[الكاملو]', '[الكاملى]', '[الكاملي]', '[المتقاربء]', '[المتقاربا]', '[المتقاربب]', '[المتقاربت]', '[المتقاربث]', '[المتقاربج]', '[المتقاربح]', '[المتقاربخ]', '[المتقاربد]', '[المتقاربذ]', '[المتقاربر]', '[المتقاربز]', '[المتقاربس]', '[المتقاربش]', '[المتقاربص]', '[المتقاربض]', '[المتقاربط]', '[المتقاربظ]', '[المتقاربع]', '[المتقاربغ]', '[المتقاربف]', '[المتقاربق]', '[المتقاربك]', '[المتقاربل]', '[المتقاربم]', '[المتقاربن]', '[المتقاربه]', '[المتقاربو]', '[المتقاربى]', '[المتقاربي]', '[الوافرء]', '[الوافرا]', '[الوافرب]', '[الوافرت]', '[الوافرث]', '[الوافرج]', '[الوافرح]', '[الوافرخ]', '[الوافرد]', '[الوافرذ]', '[الوافرر]', '[الوافرز]', '[الوافرس]', '[الوافرش]', '[الوافرص]', '[الوافرض]', '[الوافرط]', '[الوافرظ]', '[الوافرع]', '[الوافرغ]', '[الوافرف]', '[الوافرق]', '[الوافرك]', '[الوافرل]', '[الوافرلا]', '[الوافرم]', '[الوافرن]', '[الوافره]', '[الوافرو]', '[الوافرى]', '[الوافري]']
    """

    return data


def get_separate_poems(data: pd.DataFrame) -> List[str]:
    """
    تقوم هذه الدالة بفصل البيانات بناءً على القصيدة
    بحيث يتم وضع كل قصيدة في نص منفصل عن باقي البيانات
    ويتم إرجاع هذه القصائد المنفصلة في نهاية الدالة.
    """

    data = list(data.itertuples(name='Row', index=False))

    index = 0
    poems = list()
    while index < len(data):
        prev_row = None
        current_poem = list()

        while index < len(data):
            row = data[index]

            if prev_row == None or sum([row[i] == prev_row[i] for i in range(5)]) == 5:
                current_poem.append(row[-1])
            else:
                prev_row = None
                break

            index += 1
            prev_row = row

        if len(current_poem) != 0:
            poems.append(' '.join(current_poem))

    return poems


def main(args: argparse.Namespace) -> None:
    data = pd.read_csv(args.input_file)
    filtered_data = filter_data(data, args.required_metres)
    processed_data = process_data(filtered_data)

    poems = get_separate_poems(processed_data)

    with open(args.output_file, 'w') as fp:
        fp.write('\n'.join(poems))


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--input_file',
        default='data/Arabic Poem Comprehensive Dataset (APCD).csv',
        help='مسار البيانات',
    )
    parser.add_argument(
        '--output_file',
        default='generator/data/Preprocessed Arabic Poem Comprehensive Dataset (APCD).txt',
        help='مسار كتابة البيانات بعد المعالجة',
    )
    parser.add_argument('--required_metres', type=int, default=9, help='العدد المطلوب من البحور الشعرية')
    args = parser.parse_args()

    main(args)
